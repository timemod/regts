
---
title: "Introduction to regts"
author: "Rob van Harrevelt and Anita van der Roest"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction to regts}
-->

\newcommand{\longerpage}[1][1]{\enlargethispage{#1\baselineskip}}
\newcommand{\shorterpage}[1][1]{\enlargethispage{-#1\baselineskip}}
\newcommand{\needlines}[1]{\Needspace{#1\baselineskip}}


```{r echo = FALSE, message = FALSE}
library(regts)
library(readxl)
data <- matrix(c(3,2,4,3,5,2,5,3), ncol = 2)
data1 <- matrix(c(1,3,2,6,4,8,3,0,9), ncol = 3)

# input/output chunks are separated
# R inputlines start with >, outputlines with nothing
knitr::opts_chunk$set(collapse = FALSE, comment = "", prompt = TRUE)

# set options for page width = 100
options(width = 100)

```


# Introduction

When you start looking in R for timeseries you easily find several 
classes and packages, class `ts` from the `stats` package and packages `zoo` 
and `xts` being mentioned most.

The function `ts` creates a regular timeseries object with class `ts`. This can 
be a univariate or multivariate object. For class `ts` a basic infrastructure is 
available. But selecting period ranges with the `window` function is cumbersome, 
especially for non-annual timseries. 

Package `zoo` is particularly aimed at irregular timeseries. Also `zoo` is not as fast as the `ts` class.

Package `xts` facilitates period selection, but concentrates more on daily 
(or weekly) based data.

Our aim is a timeseries package defined for regular timeseries objects with the advantages of the `ts` class, but with features for easier selecting periods. Therefore we created a new package `regts`.

The `regts` package defines a class `regts` that is a subclass of the `ts` class.
Because of this the `regts` class benefits of all the functionality of `ts`.
The period handling is easier than in the `ts` class, particularly for 
monthly, quarterly and annual timeseries.

 
Package `regts` provides some more extensions to class `ts`: 

* functions for easily reading and writing timeseries to Excel and csv
* the use of labels, a description of the timeseries
* an easy way to convert a data frame to a timeseries object
* a function to calculate differences between multiple timeseries
* and furthermore a special set of aggregation functions for timeseries representing growth rates 

To use this package `regts` load it with:
```{r eval = FALSE}
library(regts)
```


# `regts` objects

## Single timeseries
A single `regts` timeseries is created with the function `regts`. An example for 
a quarterly timeseries:

```{r echo = 1}
tq <- regts(1:10, start = "2016q3")
tq
```
The end period of the timeseries is based on the length of the input data.
The period indicator can be uppercase ("Q") or lowercase ("q").
The period can also be a month, like `"2016M3"`, or a year: 

```{r echo = 1}
ty <- regts(c(.11, .29, .18, .24), start = 2017)
ty
```
Note that annual timeseries are printed differently than quarterly timeseries.

The `class` of `tq` and `ty` is `regts`, and because of the inheritance, also `ts`.
```{r}
class(tq)
```

If the input data is longer than you require you can make a selection with the 
`end` argument:

```{r}
ts_data <- regts(1:10, start = "2016q1", end = "2016q4")
```
If the input data is shorter than the period determined by the `start` and the 
`end` argument, the data is repeated:

```{r}
ts_data <- regts(1:2, start = "2016q1", end = "2017q1")
ts_data
```
As you can see the length of the period doesn't have to be a multiple of the 
length of the input data.

Class `regts` recognizes special formats for quarterly (`2016Q1`) and monthly 
(`2016M1`) timeseries.
To create timeseries with a different frequency, specify the frequency argument:

```{r}
ts_data <- regts(1:10, start = "2016-1", end = "2017-1", frequency = 2)
```

Instead of arguments `start` and `end` you can also specify argument `period`:
```{r}
ts_data <- regts(1:10, period = "2016Q1/2016Q4")
```
Input for this period may be a character string as shown above, but also a 
variable of type `period_range`. See section \ref{period_range}.

## Multivariate timeseries \label{multits}
Sometimes it is more convenient to combine several timeseries with the same 
period in a single object: a multivariate timeseries. 
A multivariate timeseries is just a matrix with two or more columns.
multivariate `regts` is such a matrix with some extra attributes. 

```{r}
rts <- regts(matrix(1:9, ncol = 3), start = "2016q1", names = c("a", "b", "c"))
rts
```
Argument `names` can be used to set the column names. If omitted then the 
column names of the input matrix are used. In the next example the input 
matrix has no column names:

```{r}
rts1 <- regts(matrix(1:9, ncol = 3), start = "2016q1")
rts1
```

A multivariate timeseries inherits the classes `mts` (multivariate `ts`), 
`ts` and `matrix`:

```{r}
class(rts)
```

Timeseries names are preferably valid R names (only include a-z, A-Z, _, 
and 0-9 and start with a letter) and well chosen. In general they will be brief. 
If more documentation is needed for a timeseries than just this (short) name, 
optionally labels can be added (see also section \ref{labels}.


### Column selection and creation

Column selection for `regts` is the same as for matrices. 

```{r}
a1_ts <- rts[ , "a"]
a1_ts
ac_ts <- rts[ , c("a", "c")]
ac_ts
```
`a1_ts` is now a univariate timeseries, `ac_ts` a multivariate subset of `rts`. 

For the `regts` class we can also create new columns:

```{r}
rts[, "x"] <- 2 * rts[, "a"]  # creating a new column "x"
rts
```

This is not possible for classes `ts` and `matrix`.

Besides the 'matrix' selection you can also use the `$` to select or create one
column in a multivariate `regts`:

```{r}
ats <- rts$a
rts$d <- rts$c + 1
```



### Selecting columns with a regular expression
The `regts` package contains a function `select_columns` to select columns of 
an R object with column names. Besides `regts` this can be a `matrix` or a 
`data frame`. The columns with names matching a given regular expression are 
selected. A few examples:

```{r}
rts <- regts(matrix(1:8, ncol = 4), start = "2016Q1", names = c("a1", "b1", "a2", "b2"))
select_columns(rts, regex = "a.*")  # all columns with names starting with "a"
select_columns(rts, regex = ".+1")  # all columns with names ending with 1
```

The syntax of `regular expression` patterns is described in the R Documentation.


## Matrices with one column
If a `regts` is created from a matrix with only one column, the timeseries is 
single (or univariate). So there are two types of single timeseries: one that 
is based on a vector and one that is based on a one-column matrix: 

```{r}
ts      <- regts(1:8, start = "2016Q1")
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1")
```
They have identical output:
```{r}
ts
ts_1col
```
and identical classes:

```{r}
class(ts)
class(ts_1col)
```

but different underlying data.

Another difference between the 'vector' version and the 'matrix-1-column' 
version is that the latter can have a column name:

```{r}
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1", names = "a")
```
The column name is not printed with the output, but can be shown with the 
`View` or the `colnames` function:

```{r}
colnames(ts_1col)
```

Single 'vector' timeseries never have a column name.

A single 'matrix-1-column' timeseries is also created when a single column 
is selected from a multivariate timeseries with the argument `drop = FALSE`. 
In this case the column name is preserved. If this argument is omitted 
(or `drop = TRUE` is used) a single 'vector' timeseries is created. A possible 
column name disapppears in this case. An example:  

```{r results = "hide"}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a", "b"))

rts[ , 1, drop = FALSE] # result is a one-dimensional matrix with column name "a"
rts[ , 2]               # result is a vector, column name "b" is lost
```

## Class `regts`
Class `regts` is a subclass of class `ts` and therefore most packages accept class `ts` can handle objects of class `regts`. However there are exceptions (such as function `lm` in the `stats` package or package 'changepoint`). In that case use function `as.ts` to change the object class. 

Some packages return a class `ts` object when the input is an `regts` object. Now use function `as.regts` to adjust the object 
class.


# Period selection \label{periodselection}

Package `regts` makes it easy to select periods. Where 
for a `ts` timeseries you have to use the `window` function:

```{r}
ts <- ts(c(1,2,3,4,5,6,7,8), start=c(2016,1), end=c(2017,4), freq=4)
window(ts, start = c(2016, 4), end = c(2017, 2))
```

with a `regts` you can select periods with the selection operator `[]`. Period 
selection is a form of subsetting. 

```{r results = "hide"}
ts <- regts(1:8, start = "2016q1", end = "2017q4")
ts["2016q4/2017q2"]
```
Besides a range you can also select one period:

```{r results = "hide"}
ts["2017q1"]
```    
    
or a range with an open beginning or end:

```{r results = "hide"}
ts["/2017q2"]
ts["2017q1/"]
```
or a range with a lower frequency:

```{r}
ts["2017"]
```

If a selection is specified outside the defined range, the timeseries is filled 
with `NA` values for that range:

```{r}
ts["/2018q2"]
ts["2015q3/"] 
```

Period selection can also be applied on the left hand side of an assignment, in 
the target timeseries. The object must exist before applying selection.

```{r}
rts1 <- regts(1:8, start = "2010q1", end = "2011q4")
rts1["2011q2"] <- 2
rts1["/2010q3"] <- 99
rts1
```

The period of the timeseries can also be extended:
```{r}
rts1["2009q1/2009q2"] <- rts1["2010q3/2010q4"]
rts1
```
The missing quarters (`2009q3` and `2009q4`) are filled in with `NA` values.

##  Period selection for multivariate regts

Selecting a period for a multivariate regts is quite similar. You can select 
one or more periods, or a combination of period(s) and columns:

```{r}
rts <- regts(matrix(1:12, ncol = 3), start = "2011q1", names = c("a", "b", "c"))
rts["2011q2", ]

rts["2011q2"]                      # the , is not necessary

rts["2011q1/2012q2", c("b","c")]   # extended selection
```

All the extended elements become `NA`.

Select a combination of period and columns:

```{r}
rts["2011q4/", c("a", "b")]
```

Selection can also take place in the target timeseries:

```{r echo = 1:3}
rts[, "x"] <- NA              # define an extra column
rts["2012q1", ] <- 99         # extend period for all columns 
rts["2011", "x"] <- 1         # update all quarters in 2011 in column "x"
rts
```



# Reading and writing timeseries 

Some common used file types to store data in R are R data, csv or xls(x) files.
Inside R projects, preferably use R data files. Writing and reading R objects to 
and from R data files is fast, easy and efficient.
If data has to be exported, you can use for example csv or Excel files.

## Rds and RData file
The main R data filetypes are `Rds` and `RData`. Both filetypes are R-readable 
binary files. 

An Rds file stores a single R object. If you want to write more objects you can 
combine them in a list and write that list to the file. 
An R object can be stored to an `Rds` file by the `saveRDS` function in the 
`base` package:

```{r}
saveRDS(rts, file = "output.rds")
```
The standard extension is `.rds`.

An object saved in an `.rds` file can be reloaded  by the `readRDS` function,
and you can assign the contents of an `.rds` file, possibly under a different name.

```{r}
series <- readRDS("output.rds")
```
The result is an R object.

Another native R data type is `RData`. 
Functions `save` and `load` are available to save and restore single or multiple 
objects to and from a RData file. When loading, the objects are restored with 
the same name they had when saved (the `load` function has no `return` variable). 
This can be annoying. Also it is not clear what the result of the `load` 
function is. 


## External files \label{io}

Package `regts` includes functions for easily reading and writing timeseries to 
and from csv or Excel files.


### Reading and writing csv files\label{csv}
With the `read_ts_csv` function a `regts` variable can be read from a csv file.
This function has several handy arguments such as column and decimal separators, 
skipping rows or columns and a name function. It employs function `fread` of the 
`data.table` package.

In most cases it succeeds in finding the correct frequency and determining how 
the timeseries are stored: rowwise or columnwise. If not, extra input arguments 
can be given. Consider the following csv file 

```{r echo = FALSE, comment=""}
cat(readLines("test.csv"), sep = "\n")
```

Notice that the periods are in the first column, the other columns contain the
timeseries. The following command will do:

```{r}
read_ts_csv("test.csv")
```

The function has an argument `rowwise`. We could have used `rowwise = FALSE` to
indicate that the timeseries are stored columnwise. But in this case it is not
needed, the period column is recognised by the function.

Sometimes the csv file is transposed, as in the following example:

```{r echo = FALSE, comment=""}
cat(readLines("transpose.csv"), sep = "\n")
```

Now the periods are in the first row (column headers), the next rows contain the timeseries. Note that `;` is the field separator and that quarter `2017q3` is missing in the file, which is why parameter `strict` is needed. By default (`strict = TRUE`) is checked if the period is complete. When `strict = FALSE` the `NA` values are filled in for the missing periods.


```{r}
read_ts_csv("transpose.csv", strict = FALSE)
```
Note that we don't have to specify the field separator, since this is determined automatically. When necessary the field separator can be specified with argument 
`sep`. 

The missing quarters are filled with `NA` values, Since `regts` (and `ts`) objects, as regular timeseries, have elements for all periods between the start and end period^[`regts` and `ts` objects are regular timeseries. Packages `xts` and `zoo` provide also irregularly spaced timeseries objects. Then periods can be missing.].

The timeseries names in this file are in uppercase. If you want the names in lowercase, use argument `name_fun`:

```{r}
read_ts_csv("transpose.csv", name_fun = tolower, strict = FALSE)
```

Files may be more complicated then the examples shown above. Possibly there are comments, extra rows or columns, or redundant information in the file. This usually does not cause problems: `read_ts_csv` can skip these redundant rows. If necessary, use arguments `skiprow` and `skipcol`.

Use function `write_ts_csv` to store a `regts` timeseries in a csv file.By default the timeseries are stored rowwise (i.e. the period is written in the first row). 

```{r}
rts <- regts(matrix(1:8, ncol = 2), start = "2016q1", names = c("a","b"))
write_ts_csv(rts, "result.csv")
```

You may want to write the data in transposed form, with a different separator:

```{r}
write_ts_csv(rts, "result_transposed.csv", rowwise = FALSE, sep = "&")
```


### Reading and writing Excel files 
Package `regts` also contains functions for reading and writing `regts` objects:


* `read_ts_xlsx` (employing the `read_excel` function in package `readxl`) for reading an Excel file, both for `xls` and `xlsx` format

* `write_ts_xlsx` and `write_ts_sheet` for writing timeseries to an xlsx file. These functions employ package `openxlsx`

Function `read_ts_xlsx` works similarly as the corresponding csv function discussed in \ref{csv}. Many arguments are the same, such as `skiprow`, `skipcol`, `rowwise` and `frequency`. There are arguments to specify a sheet name and a sheet range.
Consider the next xlsx file:

```{r echo = FALSE, comment=""}
cat(readLines("series.csv"), sep = "\n")
```

This file is quite easy to read using function `read_ts_xlsx`, which returns a 
`regts` object:

```{r}
read_ts_xlsx("series.xlsx", name_fun = tolower)
```

After analysing the data on the file, the function understands that the first two lines before the period row should be skipped. Also the empty line in between is ignored. The timeseries names are converted to lowercase. By default cells with text `NA` are treated as missing values.

Function `write_ts_xlsx` is used for writing a `regts` object to an xlsx file. It creates or opens an Excel workbook depending on argument `append`. You can specify the sheetname (by default Sheet1). An example:

```{r, message = FALSE}
write_ts_xlsx(rts, "data.xlsx", sheet_name = "extra", append = TRUE)
```

In this case a sheet 'extra' is appended to the xlsx file.

Writing sheets is also possible with function `write_ts_sheet` in
combination with library `openxlsx`. 
`write_ts_sheet` can be used to write to multiple sheets to the same file. This is more efficient than repeatedly using `write_ts_xlsx` with the `append_sheet` parameter.
It is also possible to change for example cell styles, column widths or the default font of the workbook.

### Periods in files\label{fileperiods}

When reading external files with `read_ts_xlsx` or `read_ts_csv`, several period 
formats are recognised: dates, integer values (like `2019`) or texts. 
The texts must have formats recognised by function `period` 
(see section \ref{period}).
But sometimes the periods in a file are not recognised. For example when Dutch 
month names are used, as in the following example:
```{r echo = FALSE, comment=""}
cat(readLines("period.csv"), sep = "\n")
```

`regts` only understands English month names.
To read this file, we can use argument `period_fun` to specify a function that 
converts a text to a format that is recognised by `regts`. Function `dmy` (day-month-year) of package `lubridate` can be used to convert Dutch month names.  This function can convert texts such as `"1 mei 2019"` to a `Date` object which can be easily formatted to a standard period in `regts` format. Thus we must add a day 1 before the month as shown  in the example below.

<!-- the following code only runs on Windows with an installed Dutch locale --> 
```{r, eval = FALSE}
period_fun <- function(per) {
  # This function converts a period with format <monthname> <year> 
  # to a format recognised by  regts.
  
  # convert input to day-month-year (add day 1) so we can use function dmy
  per <- paste("1", per)
  
  # use locale "Dutch". This only works on Windows.
  date <- lubridate::dmy(per, locale = "Dutch", quiet = TRUE)
  
  # convert Date to string in regts format and return 
  return(format(date, "%YM%m"))
}
# Example
period_fun("mei 2019")
```


<!-- now the example that is actually run if possible --> 
```{r, echo = FALSE}

# try to set the locale to Dutch 
tryCatch({
  Sys.setlocale("LC_TIME", "Dutch")
  dutch_loc_present <<- TRUE
}, warning = function(w) {
  dutch_loc_present <<- FALSE
},  error = function(err)  {
  dutch_loc_present <<- FALSE
})

if (dutch_loc_present) {
  period_fun <- function(per) {
    per <- paste("1", per)
    date <- lubridate::dmy(per, locale = "Dutch", quiet = TRUE)
    return(format(date, "%YM%m"))
  }
  period_fun("mei 2019")
} else {
  "2019M05"
}
```

Function `dmy` has a language/country parameter (`locale`),  which must be set if the current locale is not Dutch.  In the example above, we used the name of the Dutch locale on Windows[^1]. Obviously this code only works on Windows if the Dutch locale has been installed. 

[^1]: The names of the locales are platform dependent. For example, the Dutch locale is `"Dutch"` on Windws and `"nl_NL.utf8"` on Linux.

With function `period_fun` defined above we can read an `xlsx` file as follows:
```{r eval = FALSE}
read_ts_xlsx("period.xlsx", period_fun = period_fun)
```


```{r echo = FALSE, results = "hide"}
if (dutch_loc_present) {
  read_ts_xlsx("period.xlsx", period_fun = period_fun)
}
```


### Files with deviant formats 
Sometimes data in a file needs to be processed before it can be converted to a timeseries. This happens when a file has a deviant format. 

In that case try reading information as a `data frame` type. Most functions in R for reading a csv return a `data frame`. Examples: `read.csv`, `read.csv2` and `read.table` in package `utils`. Functions, `read_xls(x)` and `read_excel` in  package `readxl` or `read.xlsx` (in package `xlsx`) for reading Excel files 
return some sort of `data frame`.

After some processing (e.g. selecting and/or deleting (parts of) rows and columns) the data frame can be converted to a `regts` as explained in section \ref{deviant}.


# Manipulating timeseries

## Operators and functions for `regts`
Since the `regts` class is a subclass of the `ts` class it inherits all functionality from this class.
All arithmetic (`+`, `-`, `*`, `/`, `^`, `%%`, `%/%`), logical (`&`, `|`, `!`), 
relational (`==`, `!=`, `<`, `<=`, `>`, `>=`) and subsetting (`[]`) operators 
applicable for a `ts` variable, can be used for a `regts` timeseries. 
Some examples:

```{r}
tx <- regts(1:10, start = "2017q1")

# operators
ty    <- 2 * tx + 1
tpyth <- tx^2 + ty^2   
modulo <- tx %% 2
tlog  <- tx < ty & ty > 1
number <- tx["2017q2"]

```
When a binary arithmetic operator is used on two timeseries objects, the 
intersection of the periods is taken:

```{r}
tx <- regts(1:6, start = "2016q1")
ty <- regts(1:6, start = "2017q1")
tx + ty
```

You can use all functions applicable to a `ts` class timeseries. Some examples:
```{r, eval = FALSE}
tsin <- sin(tx)
tlog <- log(tx)
diff(tx)
plot(tx)
```

Most functions work exactly the same for `regts` and `ts`. Exceptions are for instance `cbind` (discussed below) and `aggregate` (described in vignette [_"Temporal Aggregation of (Growth) Timeseries"_](aggregation.pdf)
For some functions alternative implementations are available (`lag_ts`, `lead_ts`, `diff_ts`, see section \ref{laglead})

  
## Combining timeseries

As we have seen all functions that are available for `ts` are also available for `regts`. The `cbind` function (an S3 generic function) is one of them: it binds two or more objects with a common frequency. With the `cbind` function it is easy to combine several univariate timeseries to a multivariate timeseries, or a combination of univariate and multivariate timeseries to a new multivariate timeseries. 

Yet the extension for `regts` has special features: arguments `union` and `suffixes`. The argument `union` affects the period range of the result. With `union = TRUE`, the default value, it is the union of the period ranges of the joined objects, otherwise the `intersection`. An example:

```{r}
rt1 <- regts(1:4, start = "2016q1")
rt2 <- regts(1:4, start = "2016q2")
```

```{r}
cbind(rt1, rt2, union = FALSE)
```

```{r}
cbind(rt1, rt2, union = TRUE)
```
For `union = TRUE` the result is padded with `NAs` if needed.

```{r echo = FALSE, results = "hide"}
data <- matrix(1:8, ncol = 2)
rt1 <- regts(data, start = "2016", names = c("a", "b"))
rt2 <- regts(data, start = "2016", names = c("d", "c"))
t1  <- ts(data, start = c(2016), names = c("a", "b"))
t2  <- ts(data, start = c(2016), names = c("d", "c"))

cbind(rt1,rt2)
ts.union(t1, t2)
cbind(t1,t2)

```

The `suffixes` argument is obligatory if the joined objects have overlapping column names:

```{r}
rt1 <- regts(data1, start = "2016q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016q1", names = c("d", "b"))

cbind(rt1, rt2, suffixes = c("_1","_2"))
```

Another difference between `cbind.regts` and `cbind.ts`^[For multivariate timeseries `cinbd.ts` adds a prefix to the column names.] (which is an alias for `ts.union`) is the treatment of the column names: in `cbind.regts` the column names are always preserved.


## Lags, leads and differences in timeseries\label{laglead}

For lagging or leading timeseries two functions are included in the `regts` package: `lag_ts` and `lead_ts`.
In these functions the specified number of lags or leads, respectively, is always positive. By default the resulting timeseries has the same period range as the input timeseries, 
An example:

```{r}
tx
lag_ts(tx, n = 2)
```
```{r}
lag_ts(tx, n = 2, keep_range = FALSE)
```
Functions `lag_ts` and `lead_ts` are alternatives for the `lag` function in the `stats` package.

As you can verify:

`lag_ts(x, n = 2, keep_range = FALSE)` is the same as `lag(x, -2)`

For lagged differences the function `diff_ts` is available which works similarly as function `diff` in the `stats` package, except that the period range of the result is by default the same as that of the input timeseries.


## Update function

Sometimes you want to use a multivariate timeseries to update another multivariate timeseries. Function `update_ts` updates the columns of a timeseries with the values in the columns of another timeseries with the same name. 

Of course the two timeseries must have the same frequency but their period ranges may be different (the values for the non overlapping periods will be set to `NA`). For the result timeseries the union of the ranges is taken. There are different methods to deal with `NA` values, for details see documentation of function `update_ts` (`help("update_ts")`).
Only common columns in both timeseries are updated. Non overlapping columns in both timeseries are added to the result.

Some examples for updating a `series1` with a `series2`:

```{r echo = FALSE}
series1 <- regts(matrix(rep(1,6), ncol = 3), start = "2017q1", names = c("a","b","c"))
series2 <- regts(matrix(rep(2,4), ncol = 2), start = "2017q1", names = c("a","d"))
series1["2017q2", "b"] <- NA
series2[, "c"] <- NA
```
```{r}
series1
series2
```
The standard way to update `series1` is using method `upd`:
```{r}
update_ts(series1, series2, method = "upd")
```
As much values as possible are updated. Columns `b` and `d` are added to the result.

Now only replace `NA` values in the first timeseries with values from the second timeseries:
```{r}
update_ts(series1, series2, method = "updna")
```

When using method `updval` only valid values (i.e. not `NA`) in the second timeseries are used to update the first timeseries:
```{r}
update_ts(series1, series2, method = "updval")
```


## Multiple or chain calculations
Sometimes you have a 'chain' of calculations, where the left hand side of an equation is used in the right hand side of subsequent equations. For example:

```{r}
a <- regts(1:4, start = "2010q2")
b <- a + 1
c <- b / a
d <- lag_ts(a)  # n=1 is default
cbind(a, b, c, d)
```
The result is a multivariate `regts`.

You can also start with a multivariate timeseries and add series: 

```{r}
xts <- regts(data, start = "2010q2", names = c("a", "x"))
xts$b <- xts$a + 1
xts$c <- xts$b / xts$a
xts$d <- lag_ts(xts$a)
xts
```
Note that since `lag_ts` returns a timeseries with the same period as `xts`, we can directly assign the result to `xts$d`. When function `lag` from the `stats` package is used, we must select the appropriate period:

```{r}
xts$d <- lag(xts$a, -1)["2010Q2/2011Q1"]
```
Another option is to convert the multivariate regts to a list of univariate timeseries with the `as.list` function and apply the `within` function. 

```{r}
xts <- regts(data, start = "2010q2", names = c("a", "x"))
list <- as.list(xts)
list2 <- within(list, {
    b <- a + 1
    c <- b / a
    d <- lag_ts(a)
})
```

The result is a list. The timeseries in this list can be joined by using function `as.regts`. 

```{r}
as.regts(list2)
```
The result is a multivariate timeseries. Note that the columns corresponding to
the timeseries created in the `within` function appear in reverse order
(the last created timeseries, `d`, comes first).


Not all elements in the list have to be timeseries. For example we may create a numeric and a logical vector:

```{r}
list3 <- within(list2, {
    e <- 0
    f <- TRUE
})
list3$f
```
Function `cbind` also converts these elements to a `regts`:

```{r}
as.regts(list3)
```
The elements `e` and `f` are repeated for the whole period and the value `TRUE` is coerced to `numeric`.^[You could also add a character variable, i.e. g <- "a". 
Now the result will remain a `regts`, but all elements of the timeseries will be coerced to character data, which is probably not what you want.]



## Differences between multivariate timeseries
Comparing two multivariate timeseries with a large number of columns can be 
quite tedious. Function `tsdif` facilitates this. It compares two multivariate 
timeseries objects which must have the same frequency.
The function calculates differences between columns with the same name. The order of the columns is irrelevant.
The function used to compute the differences can be specified, by default 
normal differences are computed.
If argument `tol` has been specified then all differences smaller than `tol` will be ignored. By default `tol` is 0.


```{r}
rt1 <- regts(matrix(1:12, ncol = 3), start = "2016q1", names = c("a", "b", "c"))
# create timeseries with slight differences, larger and smaller than the tolerance factor 
rt2 <- rt1
rt2[ ,"a"] <- rt1[ ,"a"] + 0.01
rt2[ ,"b"] <- rt1[ ,"b"] + 1e-6
rt2
tsdif(rt1, rt2, tol = 1e-3)
``` 

When the function result is printed, only a brief review of the differences is 
shown. To obtain more detailed information assign the result to a variable. The 
return value is a list with several components. Some of them are shown in the 
next example.

```{r}
difvar <- tsdif(rt1, rt2, tol = 1e-3)
difvar$equal
difvar$difnames
```

In this example `equal` is `FALSE`, because there are differences larger than the 
tolerance `tol`. The names of the common columns with differences larger than 
the tolerance appear in `difnames`. Component `dif` is a `regts` with the 
computed differences of these columns. If there are no differences `dif` becomes 
`NULL`. In this case the difference between columns `a` is equal for all 
quarters: 0.01. 

In the previous example the two objects had the same column names. Now we look 
at an example where the column names are different. We create a new timeseries 
`rt3`, an extension of timeseries `rt1` with an extra column:

```{r}
rt3 <- rt1
rt3[, "d"] <- regts(9:12, start = "2016q1")
tsdif(rt1, rt3)
tsdif(rt1, rt3)$missing_names1
```

The `missing_names1` component contains the column names in the second 
timeseries that are missing in the first timeseries, in this case variable `d`. 
There are no `missing_names2`.

```{r}
tsdif(rt1, rt3)$equal
tsdif(rt1, rt3)$dif
```

All computed differences are smaller than or equal to the tolerance factor, so 
component `dif` is `NULL`. Component `equal` is `FALSE`; it is only `TRUE` if 
both component `dif` is `NULL` and there are no missing names.

Let's compare two columns of regts objects `rt1` and `rt2`: columns `b` differ 
less than the tolerance factor and columns `c` are equal. Now the result is equal:

```{r}
dif_bc <- tsdif(rt1[, c("b","c")], rt2[, c("c","b")], tol = 1e-5)
dif_bc$equal
```

As you can see the ordering of the columns makes no difference.


# Labels \label{labels}
In R it is possible to attach a label to an object, a text string describing the object. However in base R it is not possible to label the columns in a matrix or timeseries.

In the `regts` package each timeseries in a `regts` object can be equipped with 
a label. Labels can be defined when the series are created and they are preserved in most timeseries functions.

```{r}
t1 <- regts(data1, start = "2017q1", names = c("child", "adult", "senior"),
      labels = c("Age 0-17", "Age 18-65", "Age 65+"))
t1
```

As you can see the labels are not shown automatically when the timeseries are 
printed. With the `View` function you can view timeseries and their labels in 
RStudio. The result looks like this:

              child       adult       senior
           Age 0-17   Age 18-65      Age 65+
    2017Q1        1           6            3
    2017Q2        3           4            0
    2017Q3        2           8            9

The labels can also be retrieved with the `ts_labels` function:

```{r}
ts_labels(t1)
```

In combination with the `<-` operator, the `ts_labels` command can be used to 
assign labels to, or remove labels from an existing `regts`:

```{r}
tx <- regts(data, start = "2017q1")
ts_labels(tx) <- c("Trans X", "Label X")
ts_labels(tx)
ts_labels(tx) <- NULL       # remove all labels 
ts_labels(tx)
```

For updating one or more timeseries labels in a regts object, the function 
`update_ts_labels` is provided:

```{r eval = TRUE}
t1_update <- update_ts_labels(t1, labels = c(adult = "Age 18-67", senior = "Age 67+"))
```
```{r echo = FALSE}
ts_labels(t1_update)
```
Argument `labels` is a named character vector with the column names as names 
and the labels as values. 


## Reading labels from files
In this section we discuss how to read timeseries provided with labels from 
a csv or xls(x) file, or how to write timeseries including labels to a file. 
Also the situation is discussed where label information is available on a 
separate file.

### Reading timeseries with labels from a file
In csv or xlsx files the labels are often placed before or after the 
corresponding timeseries names. It is easy to read timeseries with labels from 
these files with functions `read_ts_csv` or `read_ts_xlsx`. Read the
following Excel file including the labels:

```{r echo = FALSE, comment=""}
cat(readLines("tslabels.csv"), sep = "\n")
```

```{r}
series <- read_ts_xlsx("tslabels.xlsx")
```

Now check the labels:

```{r}
ts_labels(series)
```

By default labels are read from columns between the names column and the data 
columns. Use argument `labels = no` to ignore the labels.

Labels and timeseries can also be stored columnwise:

```{r echo = FALSE, comment=""}
cat(readLines("testlabels.csv"), sep = "\n")
```

Note that this time the labels precede the timeseries names. Therefore we read 
this file with result `tseries`, using argument `labels = "before"`.  

```{r}
tseries <- read_ts_xlsx("testlabels.xlsx", labels = "before")
ts_labels(tseries)
```


### Reading labels from a separate file

Suppose we have a file with label information. This label file contains a list 
of timeseries names and the corresponding labels:

```{r echo = FALSE, comment=""}
cat(readLines("label.csv"), sep = "\n")
```

There is also a `regts` object which contains two series: `c` and `b`.

```{r}
ts <- regts(matrix(1:4, ncol=2), names = c("c", "b"), start = "2016")
```

We want to add some labels from this file to the timeseries using the function
`update_ts_labels`. Input for this function is a named character vector
containing the labels.

The label file contains the labels for the two timeseries.
Variable `dflabel` is read from the file as a `data frame` using function
`read.csv`:


```{r}
dflabel <- read.csv("label.csv", stringsAsFactors = FALSE)
dflabel
```

With the `dflabel` variable a named character vector `labels` is constructed.
The names can be set with the `names` function:

```{r}
labels <- dflabel[[2]]
names(labels) <- dflabel[[1]]
labels
```
The variable `labels` contains more labels than necessary. Also the ordering 
of the labels is not the same as in the  column names of the regts object. This 
is not a problem, the function `update_ts_labels` takes care of all that:

```{r}
ts <- update_ts_labels(ts, labels)
```

This is the result ( of `View(ts)`):

            c         b
            label_c   label_b
    2016          1         3
    2017          2         4


    
### Writing timeseries with labels to file

Functions `write_ts_csv` and `write_ts_xlsx` write timeseries to file 
automatically including the labels. By default they are written after the names.
An example:

```{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016q1", end = "2016q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
write_ts_xlsx(ts_data, "result_label.xlsx")
```

Specify `labels = "before"` to write the labels before the names and specify
`labels = "no"` to prevent the labels being written. 

## Labels in dataframes
How to handle labels when converting a `data frame` to a `regts` or vice versa 
and when transposing a `data frame` is described in section \ref{dataframe}.



# `period` and `period_range`\label{period_range}

When the same period is used several times, it is preferable to define a variable 
containing this period. This could be a text string containing a period but 
package `regts` also defines special classes representing 
periods: the `period` class for a single period and the `period_range` 
class for a range of periods. With these classes is it possible to manipulate the
`period` or the `period_range`, as shown further on in this section. 

## `period`\label{period}

A `period` object can be created with the `period` function. 

```{r}
prd <- period("2016q4")
prd
```

This function can handle several period formats. For example integers (e.g. 2020),
date objects and texts (e.g. `"2019Q4`", `"2019.4q"`, `"2019/4Q"`, `"2019-4q"` and 
`"2019_q4"`, where no distinction is made between 'q' and 'Q').
For more details see help("period").

Another example:
```{r}
prd2 <- period("2015-2", frequency = 4)
prd2
```
In this example the `frequency` has to be specified. `"2015-2"` is 
ambiguous. Here "2" denotes the second quarter but it could also be for instance 
a month indicator or a half year. The `frequency` argument is required if you 
want to define a period with a frequency other than 1, 4 or 12, since there is 
no special format for these frequencies.

Package `regts` includes functions to extract a subperiod (e.g. a quarter) or 
a year:

```{r}
get_subperiod(prd)
get_year(prd2)
```

`period` objects can be used as input for the `start` and `end` arguments of 
the `regts` function.

```{r eval = TRUE}
ts <- regts(1:10, start = prd)
```

When printed, a `period` variable seems to be nothing more than a character 
string. With the `str` function we can show the internal representation of a 
`period` object:

```{r}
str(period("2016q4"))
```

The internal representation of period `2016q4` is the number of quarters since 
the beginning of the Christian era, starting with 0 (`8067 = 2016 * 4 + 3`).

## `period_range`
There is also a `period_range`, an object that represents an interval of 
periods. Such a range can be created in the following ways:

```{r}
range <- period_range("2014q4", "2017q4")
range
period_range("2014q4/2017q4")
```

The lower or upper bound of the range may be undetermined, by skipping arguments 
or using `NULL`:


```{r}
period_range("2017q1", NULL)      # No upper bound
period_range( , "2017q1")         # No lower bound
```

Use equal periods, like `period_range("2021q2", "2021q2")`, to create a range of 
one period.

A `period_range` variable can be used in the `regts` function, specifying the 
`period` argument:
 
```{r}
range1 <- period_range("2016q1", "2016q3")
rts <- regts(matrix(1:18, ncol = 3), period = range1, names = c("a", "b", "c"))
rts
```
A `period_range` variable can also be obtained from a timeseries:

```{r}
get_period_range(rts)
```

The length of a `period_range` can be determined by the `nperiod` function:

```{r}
nperiod(range1)
```
Functions `start_period` and `end_period` are used to retrieve the first and 
last period in a `period_range`:

```{r}
start_period(range1)
end_period(range1)
range2 <- period_range(start_period(range1)+1, end_period(range1)-1)
ts <- regts(data, period = range2)
```

## Selection with period(_range) objects

In section \ref{periodselection} we have shown how periods can be selected 
with a string. A `period` can also be used to select or modify a period of a 
timeseries object.  Consider the following (previously defined) timeseries:

```{r}
rts
```
Use a `period` to select and modify the timeseries.
\longerpage[2]
```{r}
prd1 <- period("2016q2")
rts[prd1] 
rts[prd1] <- 3
rts
```

A `period_range` can be used to select and modify multiple periods:

```{r}
# define a period range and make selections
range <- period_range("2016q2", "2016q3")
var <- rts[range]     
rts[range, c("a", "b")]
# define another period range and create a new timeseries column
smpl <- period_range("2016q1", "2017q1")
rts[smpl, "xx"] <- 2                
rts
```

Note that because timeseries `xx` is created with an extended period, all 
timeseries in (multivariate regts) object `rts` are extended.


## Shifting period(s)
With operators `+` and `-` the period can be shifted. Some examples for `period`: 

```{r}
period("2016q4") + 1
p1 <- period("2015q1")
p1-5
```

And for a `period_range`:

```{r}
period_range("2016q4", "2017q4") + 1
period_range(p1, p1+4)  # a `period` as input
```

Note that one of the operands in `p1+4` must be numeric^[Command `period("2015q1") + period("2015q2")` results in an error message: 'Arithmetic operation on two periods is not allowed.'].

## Period vectors

Usually a `period` object contains only one period, because selection is only 
possible for one period. In some cases it can be handy to use a `period` vector 
with several periods of the same frequency.
In the next example a vector with 2 periods is created:

```{r}
prd2 <- period(c("2019q1", "2020q3"))
prd2
```

Two functions are available for creating a vector of consecutive periods:  `seq` 
and `get_periods`.
Function `seq` creates a sequence of periods, based on a start and an end period:
```{r}
seq(period("2019.1q"), period("2020.1q"))
```

Function `get_periods` returns a period vector of all periods in a range or
timeseries. This is used in the next example, where all periods are printed
where a timeseries is not available.

```{r}
ts <- regts(c(1, NA, 0, NA, NA, 2, 3, NA), start = "2020")
periods <- get_periods(ts)

# print periods where timeseries is not available
for (prd in as.list(periods)){
  if(is.na(ts[prd]))print(prd)
}
```

Note that we do not loop directly over the period vector, but first convert the
vector to a list. Otherwise the `period` class is lost.

# Conversion between `regts` and `data frame` \label{dataframe}

In R a data frame is a much-used type for storing data tables or vectors. It is 
therefore useful to convert a `data frame` object to a `regts` and vice versa. 
In this section we explain how this can be done. We also discuss how to handle 
labels. And we give an example how to read information from a deviant file.

## `data frame` to `regts`

Suppose we have a data frame with (numerical) data. It is possible to use such a 
data frame as input data for the `regts` function:

```{r}
df  <- data.frame(a = 1:3, b = 4:6, c = 7:9)
ts <- regts(df, start = "2017q1")             # create a multivariate regts
ts
```

Columns with character data are converted to numeric values if possible, otherwise the result is `NA`. By default the column names of the data frame are used for the timeseries names.

As with matrix input, it is also possible to specify names or add labels. 
Specifying names is already described in section \ref{multits}. Labeling of 
`data frames` will be discussed in section \ref{dflabels}.

In the previous example we had to specify the period of the result timeseries. 
Sometimes the period is already contained in the data frame, e.g. in the row 
names. Consider the following data frame:

```{r}
df <- data.frame(a = 1:3, b = 4:6)  # data frame with period in row names
rownames(df) <- c("2015q3", "2015q4", "2016q1")
df
```

Now the function `as.regts` can be used to convert a `data.frame` to a `regts`:

```{r}
ts <- as.regts(df)
ts
```

Function `as.regts` assumes that the period is stored in the row names. If the 
periods are in a column of the data frame, then argument `time_column` can be 
used to specify the column name or number. You can specify the column name or 
number of the data frame in which the period is stored. 

```{r}
# data frame with period in column 'periods'
df2 <- data.frame(periods = c("2015q3", "2015q4", "2016q1"), a = 1:3, b = 4:6)
ts2 <- as.regts(df2, time_column = "periods")
ts2
```
Function `as.regts` uses the function `period` to convert a text (like `"2019q3"`) or a number (like `2020`) to a `period`, see also section \ref{period} for more period formats.

Use argument `frequency` if the frequency cannot be inferred from the period texts:

```{r}
# data frame with periods of unknown frequency
df <- data.frame(a = 1:3, b = 4:6)
rownames(df) <- c("2015-3", "2015-4", "2016-1")
ts <- as.regts(df, frequency = 4)
```

If the data frame contains periods in another, non standard, format, it is 
possible to specify your own function for the conversion of a text to a `period`. 
Use the `fun` argument, if necessary with extra arguments 
(see also \ref{fileperiods}).

## `regts` to `data frame` 

The reverse conversion from a `regts` to a `data frame` can be achieved with 
function `as.data.frame`. The `as.data.frame` function has been extended for 
`regts` types. Variable `ts` has been previously defined:

```{r}
as.data.frame(ts)
```

The results look similar to `ts`. The timeseries names have become the data 
frame column names and the periods show up in the row names. Of course the 
`classes` are different.

## Labels when converting `data frame` to `regts` and vice versa\label{dflabels}

Base R does not have facilities for adding labels to a data frame. However the 
`labelled` package has introduced a function `var_label` that can be used to
add label attributes to data frames columns and to retrieve them. 
Package `regts` preserves these labels when converting a 
`regts` object with labels to a `data frame` or vice versa. 

Consider the following data frame:
```{r}
df <- data.frame(a = 1:3, b = 6:8, c = 10:12)
rownames(df) <- c("2017", "2018", "2019")
```

Now add labels to the columns of the data frame. First load the library:
```{r}
library(labelled)
var_label(df) <- list(a = "aap", b = "noot", c = "mies")
```

If you want to see the labels in the result, retrieve them with the `label` 
function^[You can also view the whole data frame including labels with the 
`View` function in Rstudio.].

```{r}
var_label(df, unlist = TRUE)
```

When this data frame with labels is converted to a multivariate regts you can 
display the labels as usual employing the `ts_labels` function:

```{r}
tt <- as.regts(df)
ts_labels(tt)
```

Similarly, if a `regts` object with labels is converted to a data frame, then 
the timeseries labels are used to create the label attributes of the data frame.

```{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016q1", end = "2016q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
df1 <- as.data.frame(ts_data)
var_label(df1)
```

## Transposing a `data frame` 

Sometimes it is necessary to transpose a `data frame`. Package `regts` 
includes a transpose function: `transpose_df`. This function also takes the 
labels into account. For example let's transpose Variable `df` defined in the 
previous section.

```{r}
df
```

```{r}
dft <- transpose_df(df)
dft
```

As you can see, if a data frame contains labels, the `transpose_df` function 
puts the labels in the first column of the result data frame. The labels have 
now become data and the resulting data frame contains no labels.

However, function `transpose_df` has an argument `label_column`. If you 
specify this argument, then the values in the selected column are used to 
create labels:

```{r collapse = TRUE}
df2 <- transpose_df(dft, label_column = "label")
df2
var_label(df2, unlist = TRUE)
```

## Example: reading timeseries from a deviant file \label{deviant}
As discussed in section \ref{io} package `regts` provides functions for directly 
reading timeseries from csv or Excel files (`read_ts_csv` and `read_ts_xlsx`). 
However, sometimes these functions cannot be used, because the file has a 
deviant layout.In that case try reading the information as a form of data frame 
and convert this data frame to a `regts` timeseries. An example file:


```{r echo = FALSE, comment=""}
cat(readLines("test.txt"), sep = "\n")
```

The timeseries are stored rowwise, but there are extra comment lines with a 
description of the three variables below. We want to use these descriptions to 
create labels for the timeseries. If we didn't need them, there would be no 
problem, comment rows are normaly skipped when using functions `read_ts_csv` and 
`read_ts_xlsx`.
A more serious problem is that there are no unique variable names. Therefore we 
want to combine columns 'soort' and 'kt' to create these names.

Read this file with the `read_excel` function with argument `.name_repair` to avoid warnings, because of the empty column names^[Argument `.name_repair` is used for the treatment of problematic column names. When "minimal" no name repair or check is performed.]. The result of this function is a `tibble`, a special sort of data frame. 
```{r}
df <- read_excel("test.xlsx", .name_repair = "minimal") 
df
```

For collecting the labels, select the rows^[For selecting a single column by 
position from a `tibble`  `[[`  is used.] with label information (not `NA`). 
```{r}
is_label_row <- !is.na(df[[1]])
labels <- df[[1]][is_label_row]
labels
```
Each label is used three times:
```{r}
labels <- rep(labels,each = 3)
```

Remove comment rows by selecting rows with `NA` in first column. This is the
reverse of the selection we applied before.
```{r}
df <- df[!is_label_row, ]
```

Next construct lowercase row names from columns soort and kt
```{r}
df$names <- tolower(paste(df$soort, df$kt, sep = "_"))
df$names
```

Now remove redundant columns 1 to 4 ('X__1', 'kt', 'soort' and 'type') and 
transpose the data frame with the `colname_column` argument to set the column 
names:
```{r}
df[1:4] <- NULL
dft <- transpose_df(df, colname_column = "names")
```

Finally, convert to regts and add the labels.

```{r}
rts <- as.regts(dft)
ts_labels(rts) <- labels
rts
```




<!--
-->













